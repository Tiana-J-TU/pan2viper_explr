// Start [manual] translation of `tx_provide()` from `ethernet.pan`

domain myBV interpretation (SMTLIB: "(_ BitVec 64)", Boogie: "bv64") {

   function toBV64(i: Int): myBV interpretation "(_ int2bv 64)"
   function toInt(bv: myBV): Int interpretation "(_ bv2int 64)"

   function xor(b1: myBV, b2: myBV): myBV interpretation "bvxor"
   function and(b1: myBV, b2: myBV): myBV interpretation "bvand"
   function or(b1: myBV, b2: myBV): myBV interpretation "bvor"
   function add(b1: myBV, b2: myBV): myBV interpretation "bvadd"
   function sub(b1: myBV, b2: myBV): myBV interpretation "bvsub"
   function mul(b1: myBV, b2:myBV): myBV interpretation "bvmul"
   function shl(b1: myBV, b2: myBV): myBV interpretation "bvshl" // Pancake `<<`
   function lshr(b1: myBV, b2: myBV): myBV interpretation "bvlshr" // Pancake `>>>`
   function ashr(b1: myBV, b2: myBV): myBV interpretation "bvashr"// Pancake `>>`
   function not(b1: myBV): myBV interpretation "bvnot"

   function toBool(bv: myBV): Bool 

   axiom ax_toBool {
      forall b:myBV :: { toBool(b) }
         (toInt(b) == 0 ==> toBool(b) == true) &&
         (toInt(b) != 0 ==> toBool(b) == false)
   }
}

domain Shape {
   function shape_One(): Shape
   function cons_shape(ls: Seq[Int]): Shape // TODO: refine this

}

domain Record { // Can I parameterise on Shapes?

   // Hopefully the only use case here
   function get_word_field(r: Record,i: Int): myBV 
}
// for now, just set a base address value via a define
define _base toBV64(0) // base addr is at 0
// #define WORD_SIZE 8
define WORD_SIZE toBV64(8)
// #define MAX_COUNT 256
define MAX_COUNT toBV64(256)
// #define NET_BUFF_DESC_SIZE  (2 * WORD_SIZE)
define NET_BUFF_DESC_SIZE mul(toBV64(2), WORD_SIZE)
// #define HW_RING_SIZE (3 * WORD_SIZE + MAX_COUNT * NET_BUFF_DESC_SIZE)
define HW_RING_SIZE add(mul(toBV64(3), WORD_SIZE), mul(MAX_COUNT, NET_BUFF_DESC_SIZE))
// #define TX_COUNT 256
define TX_COUNT toBV64(256)
// #define ETH_FUNC_BASE
define ETH_FUNC_BASE add(_base,toBV64(8360))
// #define TXD_READY (1 << 15)
define TXD_READY shl(toBV64(1),toBV64(15))
// #define TXD_ADDCRC (1 << 10)
define TXD_ADDCRC shl(toBV64(1),toBV64(10))
// #define TXD_LAST (1 << 11)
define TXD_LAST shl(toBV64(1),toBV64(11))
// #define MASK_16 65535
define MASK_16 toBV64(65535)
// #define WRAP (1 << 13)
define WRAP shl(toBV64(1),toBV64(13))
// #define DESCRIPTOR_SIZE WORD_SIZE
define DESCRIPTOR_SIZE WORD_SIZE
// #define TDAR_OFFSET 20
define TDAR_OFFSET toBV64(20)
// #define TDAR_TDAR (1 << 24)
define TDAR_TDAR shl(toBV64(1),toBV64(24))

// #define THREAD_MEMORY_RELEASE()         \
//     @THREAD_MEMORY_RELEASE(0,0,0,0);    \
method EXT_THREAD_MEMORY_RELEASE(a1: myBV, a2: myBV, l1: myBV, l2: myBV)
   requires true
   ensures true
{}

// Double check that dest & src arguments appear in this order 
method shared_ldw(d: myBV, s: myBV) 
   requires true
   ensures true
{}

method shared_ld32(d: myBV, s: myBV)
   requires true
   ensures true
{}

method shared_stw(a: myBV, v: myBV) 
   requires true
   ensures true
{}

method shared_st8(a: myBV, v: myBV) 
   requires true
   ensures true
{}

method shared_st32(a: myBV, v:myBV)
   requires true
   ensures true
{}

method net_dequeue_active(q: myBV, a: myBV) returns (r: Bool)
   requires true
   ensures true
{}

method lds(s: Shape, a: myBV) returns (v: Record) 
   requires true
   ensures true
{}

define bv_zero toBV64(0)
method tx_provide() returns (r: Int) {

  /* 
    var reprocess = true;
    get_hw_ring_tx(hw_ring_tx) // macro
    get_tx_queue(tx_queue)     // macro
    get_eth_regs(eth)          // macro
  */

  var reprocess : Bool := true
  // Expanded macro for `get_hw_ring_tx(hw_ring_tx)`
  var hw_ring_tx: myBV := add(add(_base,mul(toBV64(9),WORD_SIZE)),HW_RING_SIZE)  
  // Expanded macro for `get_tx_queue(tx_queue)`
  var tx_queue: myBV := add(_base,mul(toBV64(6), WORD_SIZE))
  // Expanded macro for `get_eth_regs(eth)`
  var addrs:myBV := _base
  var eth_R: Record := lds(shape_One(), addrs) 
  // Loading the Shape `1` has to be done in two steps (because of how I've encoded `lds` & Shapes)
  var eth: myBV := get_word_field(eth_R,0)

  while (reprocess) {
    while (true) {
      /*
        hw_ring_full(full, hw_ring_tx, TX_COUNT)
        net_queue_empty_active(empty, tx_queue)
        if (full || empty) {
           break;
        }
      */
      
      // Expanded macro for `hw_ring_full(full, hw_ring_tx, TX_COUNT)
        // Expanded macro for `hw_ring_get_tail(tail, hw_ring)` 
      var tail: myBV := toBV64(0)
      shared_ldw(tail, hw_ring_tx)

        // Expanded macro for `hw_ring_get_head(head, hw_ring)`
      var head: myBV := toBV64(0)
      shared_ldw(head, add(hw_ring_tx, WORD_SIZE))

      var value : myBV := sub(tail, add(head, toBV64(1)))
        // Expanded macro for `pnk_modulo(mod, value, ring_size)`
      var pnk_modulo_mask: myBV := sub(TX_COUNT, toBV64(1))
      var mod: myBV := and(value, pnk_modulo_mask)

      var full: Bool := (toInt(mod) == 0)

      // Expanded macro for `net_queue_empty_active(empty, tx_queue)`
      //  Expanded macro for `get_active_tail(tail, tx_queue)`                 
         // Expanded macro for `get_active_queue(tail, tx_queue)`
      tail := toBV64(0)
      shared_ldw(tail, add(tx_queue, WORD_SIZE))

         // Expanded macro for `get_tail(tail, tx_queue)`
      tail := toBV64(0)
      shared_ldw(tail, tx_queue)

      //  Expanded macro for `get_active_head(head, tx_queue)`                 
         // Expanded macro for `get_active_queue(head, tx_queue)`
      tail := toBV64(0)
      shared_ldw(tail, add(tx_queue, WORD_SIZE))

         // `get_head(head, tx_queue)`
      head := toBV64(0)
      shared_ldw(head, add(tx_queue, WORD_SIZE))

      var empty: Bool := toInt(sub(tail,head)) == 0                     
   
      if (full || empty) {
         // break // Well this doesn't work - deal with it later
      }

      // --- END OF BLOCK 1 ------------------------------------------------------- //

      var buffer_addr: myBV := add(ETH_FUNC_BASE, toBV64(512))
      var err: Bool := net_dequeue_active(tx_queue, buffer_addr) // Not sure about typing here
      inhale !err // temporary assumption so that no verification errors -- REMOVE LATER
      assert(!err) // This is also maybe not we want (Viper will really try to check this)

      // --- END OF BLOCK 2 ------------------------------------------------------- //
      // ^-- This part requires some revision --------------------------------------//

      /* var stat = TXD_READY | TXD_ADDCRC | TXD_LAST; // uint16_t
         hw_ring_get_tail(hw_tail, hw_ring_tx)
         if ((hw_tail + 1) == TX_COUNT) {
               stat = (stat | WRAP) & MASK_16;
         }
         hw_ring_get_descr_mdata(buff, hw_tail, hw_ring_tx)
         var buffer = lds {2} buffer_addr;
         !stw buff, buffer.0;
         !stw buff + WORD_SIZE, buffer.1;
      */

      var stat: myBV := or(TXD_READY, or(TXD_ADDCRC, TXD_LAST)) // Could make this a 16-len bitvector
      // Expanded macro for `hw_ring_get_tail(hw_tail, hw_ring_tx)`
      var hw_tail: myBV := toBV64(0)
      shared_ldw(hw_tail, hw_ring_tx)

      if (add(hw_tail,toBV64(1)) == TX_COUNT) {
         stat := and(or(stat, WRAP), MASK_16)
      }
      // Expanded macro for `hw_ring_get_descr_mdata(buff, hw_tail, hw_ring_tx)`
      var buff: myBV := add(hw_ring_tx,add(toBV64(16),mul(hw_tail, NET_BUFF_DESC_SIZE)))

      var buffer: Record := lds(cons_shape(Seq(2)), buffer_addr)
      shared_stw(buff, get_word_field(buffer,0))
      shared_stw(add(buff, WORD_SIZE), get_word_field(buffer,1))
      
      // --- END OF BLOCK 3 ------------------------------------------------------- //
    
      /* 
         get_io_or_offset(io_or_offset, buffer_addr)
         get_len(len, buffer_addr)
         update_ring_slot(hw_ring_tx, hw_tail, io_or_offset, len, stat)
      */

      // Expanded macro for `get_io_or_offset(io_or_offset, buffer_addr)`
      var io_or_offset: myBV := toBV64(0)
      shared_ldw(io_or_offset, buffer_addr)
      // Expanded macro for `get_len(len, buffer_addr)`
      var len: myBV := toBV64(0)
      shared_ldw(len, add(buffer_addr,WORD_SIZE))
      // Expanded macro for `update_ring_slot(hw_ring_tx, hw_tail, io_or_offset, len, stat)`
         // Expanded macro for `hw_ring_get_descr(descr, hw_ring_tx)
      var addr: myBV := add(hw_ring_tx,add(mul(toBV64(2),WORD_SIZE),mul(MAX_COUNT,NET_BUFF_DESC_SIZE))) 
      var descr_R: Record := lds(shape_One(), addr)
      // Next line is because of how I've set up shapes..
      var descr: myBV := get_word_field(descr_R,0) 

      var dst_addr: myBV := add(descr, mul(hw_tail,DESCRIPTOR_SIZE))
      var descriptor: myBV := or(shl(stat, toBV64(16)), len)
      shared_st32(dst_addr, descriptor)
      shared_st32(add(dst_addr,toBV64(4)), io_or_offset)

      // --- END OF BLOCK 4 ------------------------------------------------------- //
  
      /* 
         hw_tail = hw_tail + 1;
         pnk_modulo(mod, hw_tail, TX_COUNT)
         hw_ring_set_tail(mod, hw_ring_tx)
      */

      hw_tail := add(hw_tail, toBV64(1))
      // Expanded macro for `pnk_modulo(mod, hw_tail, TX_COUNT)`
      var pnk_modulo_mask_1: myBV := sub(TX_COUNT, toBV64(1))
      var mod_1: myBV := and(hw_tail, pnk_modulo_mask_1)

      // Expanded macro for `hw_ring_set_tail(mod, hw_ring_tx)`
      shared_stw(hw_ring_tx, mod_1)

      // --- END OF BLOCK 5 ------------------------------------------------------- //

      /*
         get_eth_tdar(tdar, eth)
         if (!(tdar & TDAR_TDAR)) {
            set_eth_tdar(TDAR_TDAR, eth)
         }
      */
      // Expanded macro for `get_eth_tdar(tdar, eth)`
      var tdar: myBV := toBV64(0)
      shared_ld32(tdar, add(eth, TDAR_OFFSET))

      if (!toBool(and(tdar, TDAR_TDAR))) {
         // Expanded macro for `set_eth_tdar(TDAR_TDAR, eth)
         shared_st32(add(eth, TDAR_OFFSET), tdar)
      }

    }
   /*
    net_request_signal_active(tx_queue)
    reprocess = false;
   */
   // Expanded macro for `net_request_signal_active(tx_queue)`
      // Expanded macro for `get_active_queue(queue, tx_queue)
   var queue: myBV := toBV64(0)
   shared_ldw(queue, add(tx_queue, WORD_SIZE))
      // Expanded macro for `clear_consumer_signalled(queue)`
   var signal: myBV := toBV64(0)
   shared_st8(add(queue,mul(WORD_SIZE, toBV64(2))),signal) // ??

   EXT_THREAD_MEMORY_RELEASE(bv_zero,bv_zero,bv_zero,bv_zero)
   reprocess := false

   /*
      hw_ring_full(full, hw_ring_tx, TX_COUNT)
      net_queue_empty_active(empty, tx_queue)
      if ((!full) && (!empty)) {
         net_cancel_signal_active(tx_queue)
         reprocess = true;
      } 
   */

   // Expanded macro for `hw_ring_full(full, hw_ring_tx, TX_COUNT)
      // Expanded macro for `hw_ring_get_tail(tail, hw_ring_tx)` 
      var tail_1: myBV := toBV64(0)
      shared_ldw(tail_1, hw_ring_tx)

      // Expanded macro for `hw_ring_get_head(head, hw_ring_tx)`
      var head_1: myBV := toBV64(0)
      shared_ldw(head_1, add(hw_ring_tx, WORD_SIZE))

      var value_1 : myBV := sub(tail_1, add(head_1, toBV64(1)))
      // Expanded macro for `pnk_modulo(mod, value, TX_COUNT)`
      var pnk_modulo_mask_2: myBV := sub(TX_COUNT, toBV64(1))
      var mod_2: myBV := and(value_1, pnk_modulo_mask_2)

      var full_1: Bool := (toInt(mod_2) == 0)

   // Expanded macro for `net_queue_empty_active(empty, tx_queue)`
     //  Expanded macro for `get_active_tail(tail, tx_queue)`                 
         // Expanded macro for `get_active_queue(tail, tx_queue)`
         tail_1 := toBV64(0)
         shared_ldw(tail_1, add(tx_queue, WORD_SIZE))

         // Expanded macro for `get_tail(tail, tx_queue)`
         tail_1 := toBV64(0)
         shared_ldw(tail_1, tx_queue)

     //  Expanded macro for `get_active_head(head, tx_queue)`                 
         // Expanded macro for `get_active_queue(head, tx_queue)`
         tail_1 := toBV64(0)
         shared_ldw(tail_1, add(tx_queue, WORD_SIZE))

         // `get_head(head, tx_queue)`
         head_1 := toBV64(0)
         shared_ldw(head_1, add(tx_queue, WORD_SIZE))

   var empty_1: Bool := toInt(sub(tail_1,head_1)) == 0                     

   if (!full_1 && !empty_1) {
      // Expanded macro for `net_cancel_signal_active(tx_queue)
        // Expanded macro for `get_free_queue(queue, tx_queue)`
      queue := toBV64(0)
      shared_ldw(queue, tx_queue)  
        // Expanded macro for `set_consumer_signalled(queue)`
      signal := toBV64(1)
      shared_st8(add(queue,mul(toBV64(2),WORD_SIZE)), signal)
      EXT_THREAD_MEMORY_RELEASE(bv_zero, bv_zero, bv_zero, bv_zero)

      reprocess := true
   }
  }
  r := 0
}