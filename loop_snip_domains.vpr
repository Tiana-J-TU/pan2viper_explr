
field val_ref: Ref
field val: Int 

domain Array {
    function loc(a: Array, i: Int): Ref 
    function len(a: Array): Int
    function loc_a(r: Ref): Array // What is this used for?
    function loc_i(r: Ref): Int

    axiom loc_injective {
    forall a: Array, i: Int :: {loc(a, i)} 0 <= i && i < len(a)
        ==> loc_a(loc(a, i)) == a && loc_i(loc(a, i)) == i
    }
    // "axiomatising injectivity via inverse
    // functions improves performance of the SMT solver by reducing the number of
    // instantiations of the axiom."
    
    axiom length_nonneg { forall a: Array :: 0 <= len(a) }
}

// Translation in same style as above, but using array domains instead

// From "array max" example: http://viper.ethz.ch/examples/max-array-elimination.html
// We have useful macros

// From Viper paper (section 5)
// Domain definition of arrays 
field val_array: Array

// We don't need triggers here?
define access(a, p) forall j: Int :: 0 <= j && j < len(a) ==> acc(loc(a, j).val, p) 
define sameupto(a, b, i) 
    len(a) == len(b) ==> (forall j: Int :: 0 <= j && j < len(a) && j < i ==> loc(a, j).val == loc(b, j).val)
// define access(a) forall j: Int :: 0 <= j && j < len(a) ==> acc(loc(a, j).val)
// define unmodified(a) forall j: Int :: 0 <= j && j < len(a) ==> loc(a, j).val == old(loc(a, j).val)define unmodified(a) forall j: Int :: 0 <= j && j < len(a) ==> loc(a, j).val == old(loc(a, j).val)
define loop_unmodified(a) forall j: Int :: 0 <= j && j < len(a) ==> loc(a, j).val == old[pre_lp](loc(a, j).val)
// define onlymodified(a, i) forall j: Int :: 0 <= j && j < len(a) && j != i ==> loc(a, j).val == old(loc(a,j).val)
// define onlymodifiedupto(a,i) forall j: Int :: 0 <= j && j < len(a) && i < j ==> loc(a, j).val == old(loc(a,j).val)
// Can we easily get unmodified(src.val_ref), given that acc to src.val_ref not exclusive?

// variant of above macro which describes modification in current iteration
// define onlymodifiedupto_curriter(a,i) forall j: Int :: 0 <= j && j < len(a) && i < j
                                    // ==> loc(a, j).val == old[pre_st8](loc(a,j).val)


method pnk_memcpy(dst: Ref, src: Ref) returns (v: Int)
    requires acc(src.val_array, 1/2) && acc(dst.val_array, write)
    requires len(dst.val_array) == 256 && len(src.val_array) == 256
    // `wildcard` amount always less than currently held -> guaranteed < 1
    // possibly replace wildcards with explicit permission assertions: ex. 1 > acc > 0 
    requires access(src.val_array, 1/2)
    requires access(dst.val_array, write)
{
    var i: Int := 0
    var c: Int := 0

    var t: Int := i

label pre_lp
    while (i < 256) // Hardcoded length 
        invariant 0 <= i && i <= 256 
                  && acc(src.val_array, 1/2)
                  && len(src.val_array) == 256
                  && access(src.val_array, 1/2) 
                  && acc(dst.val_array, write)
                  && len(dst.val_array) == 256
                  && access(dst.val_array, write) 
                  && sameupto(src.val_array, dst.val_array, i) 
                  && loop_unmodified(src.val_array)
                  // && onlymodifiedupto(..) // Deal with this once permission transfer correct
    {   
        t := i 
label pre_ld8
        // bounds check 
        // assert 0 <= t && t < len // Causes a trigger warning 
        assert 0 <= t && t < 256
        // check permission to read src segment
        assert !(perm(loc(src.val_array, t).val) == none)
        
        /* --------------------------------------------------------- */
        c := loc(src.val_array, t).val //  !ld8 c, (src + i);
        /* --------------------------------------------------------- */

label post_ld8 
        // check variable c updated with value of heap cell
        assert c == old[pre_ld8](loc(src.val_array, old[pre_ld8](t)).val)
        
label pre_st8
        // bounds check (repetitive here but maybe something that a translator might auto gen)
        assert 0 <= t && t < 256 
        // check permission to modify
        assert perm(loc(dst.val_array, t).val) == write     

        /* --------------------------------------------------------- */
        loc(dst.val_array, t).val := c // !st8 c, (dst + i);
        /* --------------------------------------------------------- */

label post_st8 
        // check heap cell updated
        assert (loc(dst.val_array, old[pre_st8](t)).val == old[pre_st8](c))
        // assert (onlymodifiedupto_curriter(dst.val_array, old[pre_st8](t)))

        i := i + 1 // i = i + 1; [translation straightforward]
    }

    // correctness criterion
    assert forall j: Int :: 0 <= j && j < 256 ==> loc(dst.val_array, j).val == old[pre_lp](loc(src.val_array, j).val)

    v := 0    
}
